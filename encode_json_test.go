package msgpack

import (
	"bytes"
	"testing"
)

//  [84 A6 A0 04 01 00 C0 00 A6 C4 04 01 00 C0 00 A6 F0 04 01 00 C0 00 01 A4 24 05 01 00 C3 A3 4B 05 01 C0]
//  [84 A6 73 74 72 69 6E 67 A6 73 74 72 69 6E 67 A6 6E 75 6D 62 65 72 01 A4 62 6F 6F 6C C3 A3 6E 69 6C C0]

func TestEncoder_encodeJSON(t *testing.T) {
	tests := []struct {
		name    string
		data    []byte
		want    []byte
		wantErr bool
	}{
		{
			"simple object",
			[]byte(`{"string":"string","number":1,"bool":true,"nil":null}`),
			[]byte{
				0x84, 0xA6, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67,
				0xA6, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0xA6,
				0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x01, 0xA4,
				0x62, 0x6F, 0x6F, 0x6C, 0xC3, 0xA3, 0x6E, 0x69,
				0x6C, 0xC0,
			},
			false,
		},
		{
			"simple array",
			[]byte(`["string",1,true,null]`),
			[]byte{
				0x94, 0xA6, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67,
				0x01, 0xC3, 0xC0,
			},
			false,
		},
		{
			"complex object",
			[]byte(`{"string":"string","number":1,"bool":true,"nil":null,"inner_obj":{"a":"a","b":"b"},"inner_arr":[{"a":"a","b":"b"},{"a":"a","b":"b"}]}`),
			[]byte{
				0x86, 0xA6, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67,
				0xA6, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0xA6,
				0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x01, 0xA4,
				0x62, 0x6F, 0x6F, 0x6C, 0xC3, 0xA3, 0x6E, 0x69,
				0x6C, 0xC0, 0xA9, 0x69, 0x6E, 0x6E, 0x65, 0x72,
				0x5F, 0x6F, 0x62, 0x6A, 0x82, 0xA1, 0x61, 0xA1,
				0x61, 0xA1, 0x62, 0xA1, 0x62, 0xA9, 0x69, 0x6E,
				0x6E, 0x65, 0x72, 0x5F, 0x61, 0x72, 0x72, 0x92,
				0x82, 0xA1, 0x61, 0xA1, 0x61, 0xA1, 0x62, 0xA1,
				0x62, 0x82, 0xA1, 0x61, 0xA1, 0x61, 0xA1, 0x62,
				0xA1, 0x62,
			},
			false,
		},
		{
			"single value",
			[]byte(`0`),
			[]byte{0x00},
			false,
		},
		{
			"invalid object",
			[]byte(`{"string"}`),
			nil,
			true,
		},
		{
			"invalid array",
			[]byte(`["string": "???"]`),
			nil,
			true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := NewEncoder(nil).encodeJSON(tt.data)
			if (err != nil) != tt.wantErr {
				t.Errorf("encodeJSON() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !bytes.Equal(got, tt.want) {
				t.Errorf("encodeJSON() got = [% X], want [% X]", got, tt.want)
			}
		})
	}
}
